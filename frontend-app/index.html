<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Remove Content-Security-Policy that's causing SSL errors -->
  <!-- <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> -->
  <title>Video Processing System</title>
  <!-- Fallback configuration in case scripts fail to load -->
  <script>
    // Fallback API configuration in case env.js or config.js fails to load
    if (typeof window.API_BASE_URL === 'undefined') {
      window.API_BASE_URL = 'http://13.235.75.73:3001';
      console.log('Using fallback API_BASE_URL:', window.API_BASE_URL);
    }

    // Create fallback API_CONFIG if config.js fails to load
    if (typeof window.API_CONFIG === 'undefined') {
      window.API_CONFIG = {
        BASE_URL: window.API_BASE_URL || '',
        ENDPOINTS: {
          UPLOAD: '/api/upload',
          TRANSCODE: '/api/start-transcoding',
          CONFIG: '/api/config',
          JOBS: '/api/jobs',
          JOB: '/api/jobs',
          TEST_CONNECTION: '/api/test-connection',
          TEST_S3: '/api/test-s3',
          HEALTH: '/health'
        }
      };
      console.log('Using fallback API_CONFIG');
    }

    // Create fallback getApiUrl function if config.js fails to load
    if (typeof window.getApiUrl === 'undefined') {
      window.getApiUrl = function (endpoint) {
        if (!window.API_CONFIG.BASE_URL) {
          return endpoint;
        }
        return window.API_CONFIG.BASE_URL + endpoint;
      };
      console.log('Using fallback getApiUrl function');
    }
  </script>
  <!-- Include env.js first to set the API Base URL -->
  <script src="env.js"></script>
  <!-- Include config.js after env.js -->
  <script src="config.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .container {
      margin-top: 20px;
    }

    #video-player {
      width: 100%;
      max-width: 720px;
      margin: auto;
      display: block;
    }

    #resolution-menu {
      margin-top: 10px;
      text-align: center;
    }

    .upload-section,
    .jobs-section {
      margin: 20px 0;
      padding: 20px;
      border: 2px dashed #ccc;
      border-radius: 4px;
    }

    .upload-section {
      margin: 20px 0;
      padding: 20px;
      border: 2px dashed #ccc;
      border-radius: 4px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .upload-section.drag-over {
      border-color: #007bff;
      background-color: rgba(0, 123, 255, 0.1);
    }

    .drop-zone {
      padding: 40px;
      border: 2px dashed #ccc;
      border-radius: 4px;
      margin: 20px 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .drop-zone:hover {
      border-color: #007bff;
      background-color: rgba(0, 123, 255, 0.05);
    }

    .drop-zone.drag-over {
      border-color: #007bff;
      background-color: rgba(0, 123, 255, 0.1);
    }

    .drop-zone p {
      margin: 0;
      color: #666;
    }

    .drop-zone i {
      font-size: 48px;
      color: #007bff;
      margin-bottom: 10px;
    }

    .button {
      background-color: #007bff;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }

    .button:hover {
      background-color: #0056b3;
    }

    .button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .alert {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
    }

    .alert-success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .alert-error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .config-status {
      text-align: center;
      margin: 20px 0;
    }

    .job-card {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      margin: 10px 0;
    }

    .job-status {
      font-weight: bold;
      margin-bottom: 10px;
    }

    .job-logs {
      background-color: #f8f9fa;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }

    .status-PENDING {
      color: #856404;
    }

    .status-RUNNING {
      color: #004085;
    }

    .status-COMPLETED {
      color: #155724;
    }

    .status-FAILED {
      color: #721c24;
    }

    .tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: 1px solid transparent;
      margin-bottom: -1px;
    }

    .tab.active {
      border: 1px solid #ddd;
      border-bottom-color: white;
      border-radius: 4px 4px 0 0;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Log styles */
    .log-entry {
      margin-bottom: 5px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log-time {
      color: #6c757d;
      font-weight: bold;
      margin-right: 8px;
    }

    #log-container {
      border: 1px solid #dee2e6;
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }

    .log-entry.error {
      color: #dc3545;
    }

    .log-entry.success {
      color: #28a745;
    }

    .log-entry.info {
      color: #007bff;
    }

    /* Container log styles */
    .log-entry.container-log {
      margin-left: 10px;
      border-left: 3px solid #6c757d;
      padding-left: 10px;
      background-color: #f0f0f0;
      border-radius: 0 4px 4px 0;
    }

    .container-prefix {
      display: inline-block;
      width: 20px;
      text-align: center;
      margin-right: 5px;
    }

    .log-entry.container-log.success {
      border-left-color: #28a745;
      background-color: #f0f8f0;
    }

    .log-entry.container-log.error {
      border-left-color: #dc3545;
      background-color: #f8f0f0;
    }

    .log-entry.container-log.command {
      border-left-color: #6610f2;
      background-color: #f5f0ff;
      font-weight: bold;
    }

    /* Progress bar styles */
    .progress {
      height: 20px;
      margin-bottom: 15px;
    }
  </style>
</head>

<body>
  <h1>Video Processing System</h1>
  <nav style="margin-bottom: 20px;">
    <ul style="list-style: none; padding: 0; display: flex; gap: 20px;">
      <li><a href="index.html" style="text-decoration: none; color: #007bff; font-weight: bold;">Home</a></li>
      <li><a href="config.html" style="text-decoration: none; color: #007bff;">Configuration</a></li>
      <li><a href="instructions.html" style="text-decoration: none; color: #007bff;">Instructions</a></li>
    </ul>
  </nav>

  <div class="config-status" id="configStatus">
    Checking configuration...
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="upload">Upload</div>
    <div class="tab" data-tab="jobs">Jobs</div>
    <div class="tab" data-tab="player">Player</div>
  </div>

  <div class="container">
    <div id="upload" class="tab-content active">
      <div class="upload-section">
        <h2>Upload Video</h2>
        <div class="drop-zone" id="dropZone">
          <i class="fas fa-cloud-upload-alt"></i>
          <p>Drag and drop your video file here</p>
          <p>or</p>
          <button class="button" onclick="document.getElementById('videoFile').click()">Browse Files</button>
          <input type="file" id="videoFile" accept="video/*" style="display: none;">
        </div>
        <button class="button" id="uploadButton" disabled>Upload</button>
        <div id="uploadStatus"></div>
      </div>
    </div>

    <div id="jobs" class="tab-content">
      <div class="jobs-section">
        <h2>Transcoding Jobs</h2>
        <div id="jobsList"></div>
      </div>
    </div>

    <div id="player" class="tab-content">
      <div class="video-section">
        <h2>Video Player</h2>
        <input type="text" id="video-input" placeholder="Enter .m3u8 video link here"
          style="width: 100%; padding: 8px; margin: 10px 0;">
        <button class="button" id="load-button">Load Video</button>

        <video id="video-player" controls></video>
        <div id="resolution-menu">
          <label for="resolutions">Quality:</label>
          <select id="resolutions">
            <option value="auto">Auto</option>
          </select>
        </div>
      </div>
    </div>

    <div id="job-details" style="display: none; margin-top: 20px;">
      <h3>Job Details</h3>
      <div id="job-info"></div>

      <div class="card" style="margin-top: 20px;">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h4>Real-time Logs</h4>
          <div id="progress-indicator" style="display: none;">
            <div class="spinner-border spinner-border-sm text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <span class="ms-2" id="progress-text">Processing...</span>
          </div>
        </div>
        <div class="card-body">
          <div class="progress" style="height: 20px;">
            <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar"
              style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
          </div>
          <div id="log-container"
            style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 14px;">
            <div id="logs"></div>
          </div>
          <div class="form-check mt-2">
            <input class="form-check-input" type="checkbox" id="auto-scroll" checked>
            <label class="form-check-label" for="auto-scroll">
              Auto-scroll to latest logs
            </label>
          </div>
        </div>
      </div>
    </div>

    <div id="transcode-section" style="display: none; margin-top: 20px;">
      <h3>Transcode Video</h3>
      <form id="transcode-form">
        <div class="mb-3">
          <label for="video-key" class="form-label">Video Key</label>
          <input type="text" class="form-control" id="video-key" readonly>
        </div>

        <div class="mb-3">
          <label for="performance-level" class="form-label">Performance Level</label>
          <select class="form-select" id="performance-level">
            <option value="economy" selected>Economy (Lower cost, slower processing)</option>
            <option value="standard">Standard (Balanced performance and cost)</option>
            <option value="premium">Premium (Fastest processing, higher cost)</option>
          </select>
          <div class="form-text" id="performance-description">
            Economy mode uses fewer resources and costs less, but takes longer to process videos.
          </div>
        </div>

        <button type="submit" class="btn btn-primary" id="transcode-btn">Start Transcoding</button>
        <div id="transcode-status" class="mt-2"></div>
      </form>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

        tab.classList.add('active');
        document.getElementById(tab.dataset.tab).classList.add('active');
      });
    });

    // Check configuration status
    async function checkConfig() {
      try {
        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.CONFIG));
        const data = await response.json();

        if (data.configured) {
          document.getElementById('configStatus').innerHTML = `
            <div class="alert alert-success">System configured and ready</div>
            <a href="/config.html" class="button" id="configBtn">Update Configuration</a>
          `;
          document.getElementById('uploadButton').disabled = false;
        } else {
          document.getElementById('configStatus').innerHTML = `
            <div class="alert alert-error">System not configured</div>
            <a href="/config.html" class="button" id="configBtn">Configure System</a>
          `;
        }
      } catch (error) {
        document.getElementById('configStatus').innerHTML = `
          <div class="alert alert-error">Error checking configuration</div>
          <a href="/config.html" class="button" id="configBtn">Configure System</a>
        `;
      }
    }

    // Job management
    let activeJobs = new Map();

    async function updateJobs() {
      try {
        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.JOBS));
        const data = await response.json();
        const jobs = data.jobs || [];

        const jobsList = document.getElementById('jobsList');
        jobsList.innerHTML = '';

        if (jobs.length === 0) {
          jobsList.innerHTML = '<div class="alert alert-info">No active jobs found</div>';
          return;
        }

        for (const job of jobs) {
          const jobCard = document.createElement('div');
          jobCard.className = 'job-card mb-4 p-3 border rounded';

          const isProductionMode = job.taskArn === 'production-mode-task-arn';

          jobCard.innerHTML = `
            <div class="d-flex justify-content-between">
              <h5>Job ID: ${job.jobId}</h5>
              <span class="badge bg-${getStatusBadgeColor(job.status)}">${job.status}</span>
            </div>
            <div>Video: ${job.videoKey}</div>
            <div>Started: ${new Date(job.startTime).toLocaleString()}</div>
            ${isProductionMode ?
              `<div class="alert alert-warning mt-2">
                <strong>Production Mode:</strong> In Vercel's environment, transcoding is simulated. 
                For actual video processing, you would need to run this application on a server.
              </div>` : ''}
            <h6 class="mt-3">Logs:</h6>
            <pre class="job-logs p-2 bg-light" id="logs-${job.jobId}">Loading logs...</pre>
          `;

          jobsList.appendChild(jobCard);

          // Update job logs
          updateJobLogs(job.jobId);
        }

        // Schedule next update if there are active jobs
        if (jobs.some(job => job.status === 'PENDING' || job.status === 'RUNNING')) {
          setTimeout(updateJobs, 5000);
        }
      } catch (error) {
        console.error('Error updating jobs:', error);
        const jobsList = document.getElementById('jobsList');
        jobsList.innerHTML = `<div class="alert alert-danger">Error loading jobs: ${error.message}</div>`;
      }
    }

    function getStatusBadgeColor(status) {
      switch (status) {
        case 'PENDING': return 'secondary';
        case 'RUNNING': return 'primary';
        case 'COMPLETED': return 'success';
        case 'FAILED': return 'danger';
        default: return 'info';
      }
    }

    async function updateJobLogs(jobId) {
      try {
        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.JOBS + '/' + jobId));
        const job = await response.json();

        const logsElement = document.getElementById(`logs-${jobId}`);
        if (logsElement) {
          logsElement.innerHTML = job.logs.map(log =>
            `${new Date(log.timestamp).toLocaleTimeString()}: ${log.message}`
          ).join('\n');

          // Auto-scroll to bottom
          logsElement.scrollTop = logsElement.scrollHeight;
        }
      } catch (error) {
        console.error('Error updating logs:', error);
      }
    }

    // Add Font Awesome for icons
    const fontAwesome = document.createElement('link');
    fontAwesome.rel = 'stylesheet';
    fontAwesome.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css';
    document.head.appendChild(fontAwesome);

    // Drag and drop functionality
    const dropZone = document.getElementById('dropZone');
    const videoFile = document.getElementById('videoFile');
    const uploadButton = document.getElementById('uploadButton');

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    // Highlight drop zone when dragging over it
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, unhighlight, false);
    });

    // Handle dropped files
    dropZone.addEventListener('drop', handleDrop, false);

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight(e) {
      dropZone.classList.add('drag-over');
    }

    function unhighlight(e) {
      dropZone.classList.remove('drag-over');
    }

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleFiles(files);
    }

    function handleFiles(files) {
      if (files.length > 0) {
        const file = files[0];
        if (file.type.startsWith('video/')) {
          videoFile.files = files;
          uploadButton.disabled = false;
          showStatus('File selected: ' + file.name, 'success');
        } else {
          showStatus('Please select a valid video file', 'error');
        }
      }
    }

    // Handle file input change
    videoFile.addEventListener('change', function (e) {
      handleFiles(this.files);
    });

    // Check if upload is ready
    async function checkUploadReady() {
      try {
        const response = await fetch(getApiUrl('/api/check-upload-ready'));

        if (!response.ok) {
          console.error('Upload readiness check failed:', response.status);
          return false;
        }

        const result = await response.json();
        console.log('Upload readiness check:', result);

        return result.ready;
      } catch (error) {
        console.error('Error checking upload readiness:', error);
        return false;
      }
    }

    // Update upload button
    uploadButton.addEventListener('click', async () => {
      const file = videoFile.files[0];
      if (!file) {
        showStatus('Please select a video file', 'error');
        return;
      }

      // Check if upload is ready
      const isReady = await checkUploadReady();
      if (!isReady) {
        showStatus('Upload service is not ready. Please ensure the system is properly configured.', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('video', file);

      try {
        uploadButton.disabled = true;
        showStatus('Uploading...', 'info');

        // Use the getApiUrl function to get the correct API URL
        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.UPLOAD), {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('Upload failed:', response.status, errorText);
          throw new Error(`Upload failed: ${response.status} ${errorText.substring(0, 100)}`);
        }

        const result = await response.json();
        console.log('Upload response:', result);

        // Show success message and transcoding button
        const uploadStatus = document.getElementById('uploadStatus');
        uploadStatus.innerHTML = `
          <div class="alert alert-success">
            Video uploaded successfully!
            <br>
            <button class="button" onclick="startTranscoding('${result.key}')">
              Start Transcoding
            </button>
          </div>
        `;
        // Save the video key to be used by the transcoding form
        if (document.getElementById('video-key')) {
          document.getElementById('video-key').value = result.key;
        }
      } catch (error) {
        console.error('Upload error:', error);
        showStatus('Upload failed: ' + error.message, 'error');
      } finally {
        uploadButton.disabled = false;
      }
    });

    function showStatus(message, type) {
      const status = document.getElementById('uploadStatus');
      status.textContent = message;
      status.className = 'alert alert-' + type;
    }

    // Function to start transcoding
    async function startTranscoding(videoKey) {
      try {
        console.log('Starting transcoding for video key:', videoKey);

        if (!videoKey) {
          throw new Error('Invalid video key');
        }

        const uploadStatus = document.getElementById('uploadStatus');
        uploadStatus.innerHTML = `
          <div class="alert alert-info">
            Starting transcoding process...
          </div>
        `;

        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.TRANSCODE), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ videoKey })
        });

        const result = await response.json();

        if (!response.ok) {
          console.error('Transcoding error:', result);

          // Format a more helpful error message
          let errorMessage = result.error || 'Failed to start transcoding';
          if (result.message) {
            errorMessage += `: ${result.message}`;
          }
          if (result.example) {
            errorMessage += `\nExample: ${result.example}`;
          }
          if (result.details) {
            errorMessage += `\nDetails: ${result.details}`;
          }

          throw new Error(errorMessage);
        }

        console.log('Transcoding response:', result);

        uploadStatus.innerHTML = `
          <div class="alert alert-success">
            Successfully started transcoding job!<br>
            Job ID: ${result.jobId}<br>
            ${result.taskArn ? `Task ARN: ${result.taskArn}` : ''}
            ${result.taskArn === 'production-mode-task-arn' ?
            `<p class="mt-2"><strong>Note:</strong> This is running in production mode on Vercel. 
              In this environment, transcoding jobs are simulated and not actually run due to serverless limitations.
              For actual video transcoding, you would need to run this on a server or use AWS Lambda.</p>` : ''}
          </div>
        `;

        // Switch to jobs tab and update the job list
        document.querySelector('.tab[data-tab="jobs"]').click();
        updateJobs();
      } catch (error) {
        console.error('Error:', error);
        const uploadStatus = document.getElementById('uploadStatus');

        let errorMessage = error.message || 'Unknown error';
        let helpMessage = '';

        // Provide helpful guidance based on error message
        if (errorMessage.includes('task definition')) {
          helpMessage = 'Make sure your task definition is in the format "family:revision" (e.g., video-transcoder:1).';
        } else if (errorMessage.includes('ECS cluster')) {
          helpMessage = 'Verify your ECS cluster name is correct and that you have permissions to access it.';
        } else if (errorMessage.includes('subnet')) {
          helpMessage = 'Check that your subnet IDs are correctly formatted and exist in your AWS account.';
        } else if (errorMessage.includes('security group')) {
          helpMessage = 'Verify your security group IDs are correctly formatted and exist in your AWS account.';
        } else {
          helpMessage = 'Please check your AWS configuration and make sure the task definition is registered in ECS.';
        }

        uploadStatus.innerHTML = `
          <div class="alert alert-danger">
            <h5>Error starting transcoding</h5>
            <p>${errorMessage}</p>
            <p><strong>Suggestion:</strong> ${helpMessage}</p>
            <button class="button" onclick="document.getElementById('configBtn').click()">Update Configuration</button>
          </div>
        `;
      }
    }

    // Video player functionality
    const video = document.getElementById('video-player');
    const resolutionMenu = document.getElementById('resolutions');
    const loadButton = document.getElementById('load-button');
    const videoInput = document.getElementById('video-input');

    loadButton.addEventListener('click', function () {
      const videoLink = videoInput.value;
      if (!videoLink) return;

      if (Hls.isSupported()) {
        const hls = new Hls();
        hls.loadSource(videoLink);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
          resolutionMenu.innerHTML = '<option value="auto">Auto</option>';

          data.levels.forEach((level, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.text = `${level.height}p`;
            resolutionMenu.appendChild(option);
          });

          resolutionMenu.addEventListener('change', function () {
            const selectedResolution = resolutionMenu.value;
            hls.currentLevel = selectedResolution === 'auto' ? -1 : parseInt(selectedResolution);
          });
        });

        hls.on(Hls.Events.ERROR, function (event, data) {
          console.error('HLS error:', data);
        });
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = videoLink;
      }
    });

    // Global variables
    let activeJobId = null;
    let logPollingInterval = null;
    let lastLogCount = 0;

    // Performance level options
    const performanceOptions = {
      economy: {
        description: "Economy mode uses fewer resources and costs less, but takes longer to process videos (5-10 min for a 5 min video)."
      },
      standard: {
        description: "Standard mode balances performance and cost (2-5 min for a 5 min video)."
      },
      premium: {
        description: "Premium mode provides the fastest processing but at a higher cost (1-2 min for a 5 min video)."
      }
    };

    // Update performance description when selection changes
    document.getElementById('performance-level').addEventListener('change', function () {
      const selectedLevel = this.value;
      document.getElementById('performance-description').textContent =
        performanceOptions[selectedLevel].description;
    });

    // Function to start transcoding
    document.getElementById('transcode-form').addEventListener('submit', async (e) => {
      e.preventDefault();

      const videoKey = document.getElementById('video-key').value;
      if (!videoKey) {
        alert('No video key found. Please upload a video first.');
        return;
      }

      // Get selected performance level
      const performanceLevel = document.getElementById('performance-level').value;
      const selectedTaskDefinition = performanceOptions[performanceLevel].taskDefinition;

      // Show loading state
      document.getElementById('transcode-status').textContent = 'Starting transcoding...';
      document.getElementById('transcode-btn').disabled = true;

      try {
        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.TRANSCODE), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            videoKey,
            taskDefinition: selectedTaskDefinition,
            performanceLevel
          })
        });

        const result = await response.json();

        if (response.ok) {
          document.getElementById('transcode-status').textContent = 'Transcoding started!';

          // Store the job ID and start polling for updates
          activeJobId = result.jobId;

          // Show job details section
          document.getElementById('job-details').style.display = 'block';

          // Start polling for job status and logs
          startPollingJobStatus();
        } else {
          document.getElementById('transcode-status').textContent = `Failed to start transcoding: ${result.error}`;
        }
      } catch (error) {
        document.getElementById('transcode-status').textContent = `Error: ${error.message}`;
      } finally {
        document.getElementById('transcode-btn').disabled = false;
      }
    });

    // Function to start polling for job status and logs
    function startPollingJobStatus() {
      if (logPollingInterval) {
        clearInterval(logPollingInterval);
      }

      // Immediately fetch job status
      fetchJobStatus();

      // Then poll every 3 seconds
      logPollingInterval = setInterval(fetchJobStatus, 3000);
    }

    // Function to fetch job status and logs
    async function fetchJobStatus() {
      if (!activeJobId) return;

      try {
        const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.JOBS + '/' + activeJobId));
        const job = await response.json();

        // Update job info
        updateJobInfo(job);

        // Update logs
        updateLogs(job.logs);

        // If job is completed or failed, stop polling
        if (job.status === 'COMPLETED' || job.status === 'FAILED') {
          clearInterval(logPollingInterval);
          logPollingInterval = null;
        }
      } catch (error) {
        console.error('Error fetching job status:', error);
      }
    }

    // Function to update job info
    function updateJobInfo(job) {
      const jobInfo = document.getElementById('job-info');
      const progressIndicator = document.getElementById('progress-indicator');
      const progressBar = document.getElementById('progress-bar');

      // Format the start time
      const startTime = new Date(job.startTime).toLocaleString();

      // Create status badge with appropriate color
      let statusBadge = '';
      let progressPercent = 0;
      let progressText = '';

      switch (job.status) {
        case 'PENDING':
          statusBadge = '<span class="badge bg-secondary">PENDING</span>';
          progressIndicator.style.display = 'flex';
          progressText = 'Initializing...';
          progressPercent = 5;
          break;
        case 'RUNNING':
          statusBadge = '<span class="badge bg-primary">RUNNING</span>';
          progressIndicator.style.display = 'flex';

          // Estimate progress based on logs
          if (job.logs) {
            // Check for container logs to determine progress
            const containerLogs = job.logs.filter(log => log.message.includes('[Container]'));

            if (job.logs.some(log => log.message.includes('PROVISIONING'))) {
              progressPercent = 10;
              progressText = 'Provisioning resources...';
            } else if (job.logs.some(log => log.message.includes('PENDING'))) {
              progressPercent = 20;
              progressText = 'Starting container...';
            } else if (job.logs.some(log => log.message.includes('RUNNING'))) {
              // Base progress on container logs
              if (containerLogs.length > 0) {
                // Check for specific transcoding milestones
                if (containerLogs.some(log => log.message.includes('Downloaded original video successfully'))) {
                  progressPercent = 30;
                  progressText = 'Downloaded video, starting transcoding...';
                }

                // Count uploaded segments to estimate progress
                const uploadedSegments = containerLogs.filter(log =>
                  log.message.includes('segment_') &&
                  log.message.includes('successfully')
                ).length;

                if (uploadedSegments > 0) {
                  // Estimate progress based on uploaded segments and resolutions
                  progressPercent = Math.min(40 + uploadedSegments * 10, 90);
                  progressText = `Transcoding in progress (${uploadedSegments} segments uploaded)...`;
                }

                // Check for HLS files completion
                const hlsCompletions = containerLogs.filter(log =>
                  log.message.includes('HLS files for')
                ).length;

                if (hlsCompletions > 0) {
                  // Estimate progress based on completed resolutions
                  progressPercent = Math.min(60 + hlsCompletions * 10, 90);
                  progressText = `Completed ${hlsCompletions} resolution variants...`;
                }
              } else {
                progressPercent = 30;
                progressText = 'Processing video...';
              }
            }
          }
          break;
        case 'COMPLETED':
          statusBadge = '<span class="badge bg-success">COMPLETED</span>';
          progressIndicator.style.display = 'none';
          progressPercent = 100;
          progressText = 'Transcoding completed!';
          break;
        case 'FAILED':
          statusBadge = '<span class="badge bg-danger">FAILED</span>';
          progressIndicator.style.display = 'none';
          progressPercent = 100;
          progressText = 'Transcoding failed';
          break;
      }

      // Update progress text
      document.getElementById('progress-text').textContent = progressText;

      // Update progress bar
      progressBar.style.width = `${progressPercent}%`;
      progressBar.setAttribute('aria-valuenow', progressPercent);
      progressBar.textContent = `${progressPercent}%`;

      // Change progress bar color based on status
      progressBar.className = 'progress-bar progress-bar-striped';
      if (job.status === 'COMPLETED') {
        progressBar.classList.add('bg-success');
      } else if (job.status === 'FAILED') {
        progressBar.classList.add('bg-danger');
      } else {
        progressBar.classList.add('progress-bar-animated', 'bg-primary');
      }

      // Update job info HTML
      jobInfo.innerHTML = `
          <div class="card">
              <div class="card-body">
                  <p><strong>Job ID:</strong> ${job.jobId}</p>
                  <p><strong>Status:</strong> ${statusBadge}</p>
                  <p><strong>Video:</strong> ${job.videoKey}</p>
                  <p><strong>Started:</strong> ${startTime}</p>
                  <p><strong>Duration:</strong> ${getJobDuration(job.startTime)}</p>
              </div>
          </div>
      `;
    }

    // Function to calculate job duration
    function getJobDuration(startTime) {
      const start = new Date(startTime);
      const now = new Date();
      const durationMs = now - start;

      // Format duration
      const seconds = Math.floor(durationMs / 1000) % 60;
      const minutes = Math.floor(durationMs / (1000 * 60)) % 60;
      const hours = Math.floor(durationMs / (1000 * 60 * 60));

      if (hours > 0) {
        return `${hours}h ${minutes}m ${seconds}s`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      } else {
        return `${seconds}s`;
      }
    }

    // Function to update logs
    function updateLogs(logs) {
      if (!logs || logs.length === 0) return;

      const logsContainer = document.getElementById('logs');

      // Only update if we have new logs
      if (logs.length > lastLogCount) {
        // Clear logs if this is the first update
        if (lastLogCount === 0) {
          logsContainer.innerHTML = '';
        }

        // Add new logs
        for (let i = lastLogCount; i < logs.length; i++) {
          const log = logs[i];
          const logTime = new Date(log.timestamp).toLocaleTimeString();

          // Create log entry with appropriate styling
          const logEntry = document.createElement('div');
          logEntry.className = 'log-entry';

          // Style based on log content
          if (log.message.includes('error') || log.message.includes('failed') || log.message.includes('FAILED') || log.message.includes('Error')) {
            logEntry.classList.add('error');
          } else if (log.message.includes('COMPLETED') || log.message.includes('success') || log.message.includes('Successfully') || log.message.includes('successfully')) {
            logEntry.classList.add('success');
          } else if (log.message.includes('RUNNING') || log.message.includes('PROVISIONING') || log.message.includes('PENDING') || log.message.includes('Task status')) {
            logEntry.classList.add('info');
          }

          // Format the log message
          let formattedMessage = log.message;

          // Special formatting for container logs
          if (log.message.includes('[Container]')) {
            logEntry.classList.add('container-log');

            // Extract the actual message
            const containerMessage = log.message.replace('[Container] ', '');

            // Format based on content
            if (containerMessage.includes('Uploaded') && containerMessage.includes('successfully')) {
              logEntry.classList.add('success');
              formattedMessage = `<span class="container-prefix">ðŸ“¤</span> ${containerMessage}`;
            } else if (containerMessage.includes('Downloaded') && containerMessage.includes('successfully')) {
              logEntry.classList.add('success');
              formattedMessage = `<span class="container-prefix">ðŸ“¥</span> ${containerMessage}`;
            } else if (containerMessage.includes('HLS files')) {
              logEntry.classList.add('success');
              formattedMessage = `<span class="container-prefix">ðŸŽ¬</span> ${containerMessage}`;
            } else if (containerMessage.startsWith('>')) {
              logEntry.classList.add('command');
              formattedMessage = `<span class="container-prefix">$</span> ${containerMessage.substring(1).trim()}`;
            } else {
              formattedMessage = `<span class="container-prefix">ðŸ”„</span> ${containerMessage}`;
            }
          } else {
            // Highlight important parts of the message
            formattedMessage = formattedMessage.replace(/FAILED/g, '<strong class="text-danger">FAILED</strong>');
            formattedMessage = formattedMessage.replace(/COMPLETED/g, '<strong class="text-success">COMPLETED</strong>');
            formattedMessage = formattedMessage.replace(/RUNNING/g, '<strong class="text-primary">RUNNING</strong>');
            formattedMessage = formattedMessage.replace(/PROVISIONING/g, '<strong class="text-info">PROVISIONING</strong>');
            formattedMessage = formattedMessage.replace(/PENDING/g, '<strong class="text-warning">PENDING</strong>');
          }

          logEntry.innerHTML = `<span class="log-time">[${logTime}]</span> ${formattedMessage}`;
          logsContainer.appendChild(logEntry);
        }

        // Update last log count
        lastLogCount = logs.length;

        // Auto-scroll to bottom if enabled
        if (document.getElementById('auto-scroll').checked) {
          const logContainer = document.getElementById('log-container');
          logContainer.scrollTop = logContainer.scrollHeight;
        }
      }
    }

    // Initialize
    checkConfig();
  </script>
</body>

</html>